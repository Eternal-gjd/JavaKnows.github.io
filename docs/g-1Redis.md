



## Redis-常见面试题

### 面试项

1： **Redis支持的数据类型？** 

- String
- Hash
- Set
- SortSet
- list

2： **Redis有哪几种持久化方式？优缺点是什么？** 

- 提供了两种持久化方式

  - RDB(默认)

  ![1573923079705](E:\JavaSe\Demo_Picture\1573923079705.png)

  rdb:Redis DataBase缩写

  功能核心函数rdbSave(生成RDB文件) 和 rdbLoad(从文件加载内存)两个函数

  - AOF

  ![1573923215217](E:\JavaSe\Demo_Picture\1573923215217.png)

  AOF是APPend-only file 缩写

  每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会调用磁盘中的AOF文件,以以下两种工作aof写入保存

  - WRITF:根据条件 ,将aof_buf中的缓存写入到AOF文件
  - SAVE:根据条件,调用fsync 或fdatasync函数,将AOF文件保存到磁盘中

  ====>存储结构==

  内容是redis通讯协议(RESP)格式的命令文本存储

  - RESP是redis客户端和服务端之前使用的一种通讯协议
  - 特点
    - 实现简单,快速解析,可读性好

  比较:

  1. aof文件比rdb更新频率高.优先使用aof还原数据
  2. aof比rdb更安全也更大
  3. rdb性能比aof好
  4. 优先加载AOF

  

3： **Redis 集群有哪些架构模式？讲讲各自的特点** 

- 单机版
  - 特点: ====>简单==
  - 缺陷:
    1. 内存容量有限
    2. 处理能力有限
    3. 无法高可用
  - ![1574006388816](E:\JavaSe\Demo_Picture\1574006388816.png)
- 主从复制
  - 特点: 
    1. master/slave 角色
    2. master/slave 数据相同
    3. 降低master 读压力在转交从库
  - 缺陷:
    1. 无法保证高可用
    2. 没有解决master写的压力
  - ![1574006667372](E:\JavaSe\Demo_Picture\1574006667372.png)
- 哨兵
  - 特性:
    - 监控
    - 提醒
    - 自动故障迁移
  - 特点
    1. 保证高可用
    2. 监控各个节点
    3. 自动故障迁移
  - 缺点
    - 主从模式,切换需要时间,导致丢数据
  - ![1574007359421](E:\JavaSe\Demo_Picture\1574007359421.png)
- 集群(proxy型)
  - 特点
    1. 多种hash算法
    2. 支持失败节点自动删除
    3. 后端Sharding分片逻辑 对业务透明,业务的读写方式和操作单个Redis一致
  - 缺点
    1. 增加了新的proxy,需要维护其高可用
    2. failover逻辑需要自己实现,其本身不支持故障的自动转移,可扩展性差,进行扩容都需要手动干预
  - ![1574007815807](E:\JavaSe\Demo_Picture\1574007815807.png)
- 集群(直连型)
  - 特点
    1. 无中心架构(不存在哪个节点影响性能瓶颈),少了proxy层
    2. 数据按照slot存储分布在多个节点,节点空间数据共享,可以动态调整数据分布
    3. 可扩展性,可线性扩展到1000个节点,节点可动态添加或删除
    4. 高可用性,部分节点不可用时,集群仍可用,通过增加Slave做备份数据副本
    5. 实现故障自动failover,节点之间通过gossio协议交换状态信息,用投票机制完成Slave到Master的角色提升
  - 缺点
    1. 资源隔离性比较差,容易出现相互影响的情况
    2. 数据通过异步复制,不保证数据的强一致性

4： **什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？** （==难==）

- ===>缓存穿透==

  - 就是当用户访问的key,不存在对应的value,就会去后台系统对应db查找.当一些恶意的请求会故意查询不存在的key,并且请求量很大,就会对后台系统造成很大的压力,这就叫做缓存穿透

- ===>如何避免==

  - ```properties
    如何避免？
    1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
    2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。
    缓存雪崩
    当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。
    如何避免？
    
    1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
    2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
    3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
    ```

    

5：**为什么Redis的操作是原子性的，怎么保证原子性的？**

- 原子性
  - 原子性是数据库的事务中的特性.在数据库的事务情景下,原子性指的是:一个事务中的所有操作,要么全部成功,要么全部失败,不会结束在中间的某个环节
  - 对于Redis 来说,原子性是 一个操作的不可再分,命令的操作要么执行, 要么不执行
  - Redis 之所以是原子性 是因为Redis是单线程的
    - 线程:是操作系统的最小的执行单元,在单线程程序中,任务一个一个地做,必须完成一个任务后,才会去做另外一个任务
    - 在程序执行多个Redis命令的时候,Redis操作并非原子性,这也和普通的数据库的表现是一样的
  - 如何保证原子性?
    - 在Redis中,执行get , set 以及eval等API,都是一个一个的任务.当执行多个命令的时候,就无法保证redis操作的原子性
    - 通过使用Redis的事务,或者使用Redis+ Lua的方式实现
    - ====>Redis本身提供的所有API都是原子性操作,Redis中的事务其实是会保证批量操作的原子性==

6:   **Redis的过期策略以及内存淘汰机制**

- ====>定期删除 + 惰性删除==
  - ==定期删除==
    - 指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key,检查是否过期,如果过期就删除
  - ==惰性删除==
    - 由于定期删除只能随机定时的删除一些过期的key,会导致一些过期的key没有被删除到,此事只能依靠惰性删除
    - 惰性删除会在要用到该key的时候,先去检查一些这个key,是否过期,如果过期了就删除该key
  - ==内存淘汰机制==
    - 如果定期删除漏掉了大量的过期key,最后也没有走惰性删除,那么就会引发大量的过期的key堆积在内存中,导致redis内存耗尽,此时就会触发==内存淘汰机制==
    - 内存淘汰机制,当redis内存占用过多的时候,就会触发
      - ==allkey-lru== : 当内存不足以容纳新写入的数据的时候,在键空间中,就会移除最近最少使用的key
      - volatile-random : 当内存不足以容纳新写入的数据的时候,在设置了过期的键空间中,随机移除某个key
      - volatile-ttl : 当内存不足以容乃新写入的数据的时候,在设置了过期的键空间中,会优先移除更早过期的key

7:  **使用过Redis分布式锁么，它是怎么实现的？** （==难==）

```properties
先拿setnx来争抢锁,抢到之后,再用expire给锁加一个过期时间防止锁忘记了释放

如果在setnx之后执行expire之前进程意外carsh或者要重启维护了,会怎样?

--故作沉思片刻..............
我记得set指令有非常复杂的参数,这个应该是可以同时吧setnx 和 expire 合成一条指令来用

```

8：**Redis集群方案应该怎么做？都有哪些方案？**

- 方案一===>Redis官方集群方案 Redis Cluster==
  - ![1574300479416](E:\JavaSe\Demo_Picture\1574300479416.png)
- 方案二====>Redis Sharding 集群==
  - 
- 方案三====>利用代理中间件实现大规模的Redis集群==
  - **客户端Sharding技术**(自定义能力最高)
    - **优势**
      - 服务端的Redis实例彼此独立,相互关联,非常容易线性扩展,系统灵活性很强
    - **不足**
      - 由于Sharding处理放到客户端,规模扩大的时给运维带来挑战
      - 服务端Redis实例群 拓扑结构有变化时,每个客户端都需要更新调整
      - 连接不能共享,当应用规模增大时,资源浪费制约优化
  - **服务端Sharding技术**
    - **优势**
      - 服务端的Redis集群拓扑结构变化时,客户端不需要感知,客户端像使用单Redis服务器一样使用Redis Cluster,运维管理比较方便
    - **不足**
      - Redis Cluster正式版推出时间不长,系统稳定性,性能等需要的时间检验,尤其中大规模使用场景
  - **中间件Sharding分片技术**(适用于做 **缓存服务** )
    - twemproxy就是一种中间件Sharding分片的技术,处于客户端和服务端的中间,将客户端发来的请求,进行一定的处理后(如Sharding) ,再转发给后端真正的Redis服务器
    - 也就是说,客户端不能直接访问Redis服务器,而是通过twemproxy代理的中间件间接访问
    - twemproxy中间件的内部处理是无状态的,起源于twitter,不仅支持redis,同时支持memcached(*是一款开源,高性能,分布式的内存对象缓存系统,**最主要的功能**就是在内存中缓存数据,以减轻数据负载 **基本工作原理**:以守候程序的方式运行于一个或者多个服务器,随时等待客户的连接*)
    -  使用了中间件，twemproxy可以通过共享与后端系统的连接，降低客户端直接连接后端服务器的连接数量。同时，它也提供sharding功能，支持后端服务器集群水平扩展。统一运维管理也带来了方便. 由于使用了中间件，相比客户端直辖服务器方式，性能上肯定会有损耗，大约降低20%左右。 

9：**Redis集群会有写操作丢失吗？为什么？**

```properties
Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下(使用的内存超过了最大可用内存（数据淘汰策略是noenviction（驱逐）的时候）)可能会丢失写操作。
```

10：**Redis集群最大节点个数是多少？**

```properties
16384个，但是建议最多有1000个节点。
```



### 应用场景

1： 分布式会话缓存（Session Cache） 

```properties
例如：分布式登录信息，购物车信息，能提供持久化。
```

2： 全页缓存（FPC） 

```properties
除了基本的会话token之外,redis还提供简便的FPC平台,即使重启redis实例,因为有磁盘的持久化,用户也不会看到页面加载速度的下降
```

3： 排行榜/计数器 

```properties
incr range
```

4:   分布式锁

```

```

5：分布式计数器

```properties

```

6：限制IP访问请求

7：热点数据的缓存

```properties
先计算下这20W条数据占用的内存，设置最大可用内存，当内存中的数据集达到上限时，redis就会启动LRU(数据淘汰策略)。
```

8：点赞、好友等相互关系的存储

9：队列

```properties
由于支持list 和 set 操作,这使得redis能作为一个很好的消息队列平台来使用
```

10：地理定位

11：限时业务的运用





### 故障问题

1:  什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？（==难==）

- 缓存穿透
  - 一般的缓存系统,是通过key去缓存查询,如果不存在key 就会去后台数据库DB中查询.
  - 一些恶意的访问,大量访问查询不存在的key,就会导致后台系统的压力.
- 如何避免缓存穿透?
  - 对查询结果为空的情况也进行缓存,缓存的时间设置短一些,或者key对应的数据insert了之后就清理缓存
  - 对一定不存在的key进行过滤,可以包所有可能的key存放到一个大的BitMap中,查询时通过该BitMap进行过滤

2:  MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？ 

```properties
先计算这2000w数据占用的内存,设置最大的可用内存,当内存中的数据集达到上限时,redis就会启动LRU(数据淘汰策略)
```

3：分布式会话

4：分布式的统一订单编号

5：分布式锁





### 面试表达

写剧本

什么加入到公司，开发产品，开始的架构是什么样子，后续在上面阶段加入的redis,解决了什么问题，怎么解决的。你对它的认识看法是什么。































